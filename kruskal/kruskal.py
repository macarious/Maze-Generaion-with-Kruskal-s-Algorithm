'''
CS 5800 Maze Generation with Kruskal's Algorithm

This program generates a maze using Kruskal's algorithm. The maze is represented
as a 2D array of cells. Each cell is either a wall or a passage. The maze is
generated by removing walls between cells. The algorithm starts with a grid of
passages and walls. It then removes walls between cells until all cells are
connected. The algorithm removes walls by selecting a random wall and checking
if the cells on either side of the wall are connected. If the cells are not
connected, the wall is removed and the cells are connected. If the cells are
already connected, the wall is left in place. The algorithm continues until all
cells are connected.

The program uses a disjoint set data structure to keep track of which cells are
connected. The disjoint set data structure is implemented using a forest of
trees. Each tree represents a set of connected cells. Each node in the tree
represents a cell. Each node has a parent pointer that points to the parent
node. The root node of each tree represents the set. The root node has a parent
pointer that points to itself. The disjoint set data structure has two
operations: find and union. The find operation returns the root node of the tree
that contains the given node. The union operation merges two trees into one tree
by making the root node of one tree point to the root node of the other tree.
'''

import random
import sys
import time
import tkinter as tk

# The disjoint set data structure is implemented using a forest of trees. Each
# tree represents a set of connected cells. Each node in the tree represents a
# cell. Each node has a parent pointer that points to the parent node. The root
# node of each tree represents the set. The root node has a parent pointer that
# points to itself.

CELL_WALL = 1
CELL_PASSAGE = 0
WINDOW_SIZE = 750
CELL_DISPLAY_FILL = 'black'
ANIMATION_DELAY = 1000 # divided by the (number of cells) ^ 2 in the maze


'''
class DisjointSet
Description: This class implements the disjoint set data structure.
'''


class DisjointSet:

    def __init__(self, width, height):
        self.set_count = width * height
        self.parent_list = [i for i in range(self.set_count)]
        self.size_list = [1 for i in range(self.set_count)]
        self.width = width
        self.height = height
        self.color_list = [self.generate_random_hex_color() for i in range(self.set_count)]

    def find(self, cell):
        '''
        Description: This function returns the root node of the tree that contains the given node.
        Parameters: cell - The cell.
        Return: The root node of the tree that contains the given node.
        '''
        # Find the root of the tree.
        root_index = (cell.y // 2) * self.width + (cell.x // 2)
        while root_index != self.parent_list[root_index]:
            root_index = self.parent_list[root_index]

        # Compress the path leading back to the root.
        current_node = (cell.y // 2) * self.width + (cell.x // 2)
        while current_node != root_index:
            parent_node = self.parent_list[current_node]
            self.parent_list[current_node] = root_index
            current_node = parent_node

        return root_index

    def union(self, cell1, cell2):
        '''
        Description: This function merges two trees into one tree by making the root node of one tree point to the root node of the other tree.
        Parameters: cell1 - The first cell.
                    cell2 - The second cell.
        '''
        # Find the roots and stop if they are already the same.
        root1 = self.find(cell1)
        root2 = self.find(cell2)
        if root1 == root2:
            return

        # Merge the smaller tree into the larger tree.
        if self.size_list[root1] < self.size_list[root2]:
            self.parent_list[root1] = root2
            self.size_list[root2] += self.size_list[root1]
        else:
            self.parent_list[root2] = root1
            self.size_list[root1] += self.size_list[root2]
        self.set_count -= 1

    def generate_random_hex_color(self):
        '''
        Description: This function generates a random hexadecimal color.
        Return: A random hexadecimal color.
        '''
        return '#' + ''.join([random.choice('0123456789ABCDEF') for j in range(6)])


'''
class Cell
Description: This class represents a cell in the maze.
'''


class Cell:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other_cell):
        return self.x == other_cell.x and self.y == other_cell.y

    def __str__(self):
        return '(' + str(self.x) + ', ' + str(self.y) + ')'


'''
The maze is represented as a 2D array of cells. Each cell is either a wall or a
passage. The maze is generated by removing walls between cells. The algorithm
starts with a grid of passages and walls. The (odd, odd) cells are passages and
the remaining cells are walls. It then removes walls between cells until all
cells are connected. Each passage is represented as a set of connected cells in
the disjoint set data structure. The algorithm removes walls by selecting a
random wall and checking if the cells on either side of the wall are connected.
If the cells are not connected, the wall is removed and the cells are connected.
If the cells are already connected, the wall is left in place. The algorithm
continues until all cells are connected.
'''


class Maze:
    def __init__(self, width, height, root):
        # Initialize the maze. The (odd, odd) cells are passages and the remaining cells are walls.
        self.maze_width = width * 2 + 1
        self.maze_height = height * 2 + 1
        self.maze = []
        for y in range(self.maze_height):
            row = []
            for x in range(self.maze_width):
                if x % 2 == 1 and y % 2 == 1:
                    row.append(CELL_PASSAGE)
                else:
                    row.append(CELL_WALL)
            self.maze.append(row)

        # Initialize the disjoint set data structure. Exclude the walls between cells.
        self.disjoint_set = DisjointSet(width, height)

        # Create the tkinter window.
        self.root = root
        self.root.title('Maze Generation with Kruskal\'s Algorithm')
        if width > height:
            self.root.geometry(str(WINDOW_SIZE) + 'x' +
                               str(WINDOW_SIZE * height // width))
            self.canvas = tk.Canvas(self.root, width=WINDOW_SIZE,
                                    height=WINDOW_SIZE * height // width)
        else:
            self.root.geometry(str(WINDOW_SIZE * width // height) + 'x' +
                               str(WINDOW_SIZE))
            self.canvas = tk.Canvas(self.root, width=WINDOW_SIZE * width // height,
                                    height=WINDOW_SIZE)
        self.canvas.pack()

        # Generate the maze.
        self.generate_maze()

    def generate_maze(self):
        '''
        Description: This function generates the maze.
        '''
        removable_walls = []
        for y in range(self.maze_height):
            for x in range(self.maze_width):
                cell = Cell(x, y)
                if self.is_wall_removable(cell):
                    removable_walls.append(cell)

        # Remove walls until all cells are connected.
        while self.disjoint_set.set_count > 1:
            # Select a random wall.
            wall_index = random.randint(0, len(removable_walls) - 1)
            wall = removable_walls[wall_index]

            # Check if the cells on either side of the wall are connected.
            if wall.x % 2 == 1:
                cell1 = Cell(wall.x, wall.y - 1)
                cell2 = Cell(wall.x, wall.y + 1)
            else:
                cell1 = Cell(wall.x - 1, wall.y)
                cell2 = Cell(wall.x + 1, wall.y)

            if self.disjoint_set.find(cell1) != self.disjoint_set.find(cell2):
                # Remove the wall.
                self.maze[wall.y][wall.x] = CELL_PASSAGE
                self.disjoint_set.union(cell1, cell2)

                # Remove the wall from the list of removable walls.
                removable_walls.pop(wall_index)

                # Pause the execution to simulate animation delay.
                self.draw_maze()  # Update the canvas
                self.root.update()
                delay = ANIMATION_DELAY / (self.maze_width * self.maze_height) ** 2
                time.sleep(delay)

    def is_wall_removable(self, cell):
        '''
        Description: This function returns whether the wall at the given coordinates can be removed.
        Parameters: cell - The cell.
        Return: Whether the wall at the given coordinates can be removed.
        '''
        # Check if the cell is a wall.
        if self.maze[cell.y][cell.x] == CELL_WALL:
            # Check if the cell is on the edge of the maze.
            if cell.x == 0 or cell.x == self.maze_width - 1 or cell.y == 0 or cell.y == self.maze_height - 1:
                return False

            # Check if the cell is adjacent to a passage.
            if self.maze[cell.y - 1][cell.x] == CELL_PASSAGE or self.maze[cell.y + 1][cell.x] == CELL_PASSAGE or self.maze[cell.y][cell.x - 1] == CELL_PASSAGE or self.maze[cell.y][cell.x + 1] == CELL_PASSAGE:
                return True

            return False

        return False

    def draw_maze(self):
        '''
        Description: This function draws the maze in tkinter.
        '''
        self.canvas.delete('all')  # Clear the canvas

        # Draw the maze.
        cell_size = WINDOW_SIZE // max(self.maze_width, self.maze_height)
        for y in range(self.maze_height):
            for x in range(self.maze_width):
                if self.maze[y][x] == CELL_WALL:
                    self.canvas.create_rectangle(x * cell_size, y * cell_size, (x + 1)
                                                 * cell_size, (y + 1) * cell_size, fill=CELL_DISPLAY_FILL)
                else:
                    group_index = self.disjoint_set.find(Cell(x, y))
                    hex_color = self.disjoint_set.color_list[group_index]
                    self.canvas.create_rectangle(x * cell_size, y * cell_size, (x + 1)
                                                 * cell_size, (y + 1) * cell_size, fill=hex_color)

        # Update the canvas.
        self.root.update()

    def print_maze(self):
        '''
        Description: This function prints the maze.
        '''
        for y in range(self.maze_height):
            for x in range(self.maze_width):
                if self.maze[y][x] == CELL_WALL:
                    print('#', end='')
                else:
                    print(' ', end='')
            print()


def main():
    width = int(input('Width: '))
    height = int(input('Height: '))
    if width < 1 or height < 1:
        print('Error: Invalid maze dimensions.')
        sys.exit()

    root = tk.Tk()
    maze = Maze(width, height, root)

    maze.root.mainloop()


if __name__ == '__main__':
    main()
